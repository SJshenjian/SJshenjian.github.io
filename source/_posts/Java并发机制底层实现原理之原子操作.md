---
title: Java并发机制底层实现原理之原子操作
date: 2019-06-02 20:02:35
category: 多线程
tag: 多线程
---

# 1. 处理器层实现原子操作

## 1.1 使用总线锁保证原子性

 所谓总线锁,就是使用处理器提供的一个LOCK#信号，当一个处理器在总线上输出该信号时，其他处理器的总线请求将被阻塞，呢么该处理器就可以独占共享内存

## 1.2 使用缓存锁保证原子性

 “缓存锁定”指内存区域如果被缓存在缓存行中，并且在Lock操作期间被锁定，呢么执行锁操作回写到内存时，修改内部的内存地址，并允许它的缓存一致性原理保证操作的原子性。

当操作的数据不能被缓存在处理器内部或数据跨多个缓存行或处理器不支持缓存锁定，则不会使用缓存锁定，而使用总线锁定。

针对以上两个机制，Inter处理器提供了很多Lock前缀的指令来实现。如位测试和修改指令：BTS、BTR、BTC;交换指令：XADD、CMPXCHG， 被这些指令操作的内存区域会被加锁，导致其他处理器不能访问

# 2. Java层实现原子操作

在Java中可以通过**锁**和**CAS**的方式来实现原子操作

## 2.1 使用循环CAS来实现原子操作

JVM基于CAS操作正式利用了处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本思路是：循环进行CAS操作直到成功为止

### 2.1.1 CAS实现原子操作的三大问题

**ABA问题** 如果一个值原本为A，变成了B，又变成了A，呢么使用CAS进行检查时会发现它的值没有改变。ABA的解决思路是使用版本号。JDK提供AtomicStampedReference解决ABA问题。
**循环时间长开销大** 
**只能保证一个共享变量的原子操作** JDK提供AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里进行CAS操作

## 2.2 使用锁机制实现原子操作

JVM内部实现了偏向锁、轻量级锁、互斥锁。除了偏向锁，JVM实现锁的方式都采用了循环CAS













ps：术语
原子操作： 不可被中断的一个或一系列操作
