---
title: 开源框架面试篇
date: 2019-11-05 17:23:25
category: [JAVA]
tag: [JAVA,面试]
---

## 开源框架面试篇

### 1. 简单讲讲tomcat结构，以及其类加载流程，线程模型

**结构**
	+ **模块组成结构** 
		Tomcat和核心组件是Connector和Container，一个Connector和一个Container(Engine)构成了一个Service.
		Service是对外提供服务的组件，有了Service组件Tomcat就能对外提供服务了，但是光有服务还不行，还需要最外层的Server环境让Service提供服务才行。
		[追问时可回答]Collector是一个连接器，主要负责接收请求并把请求交给Container;Container是一个容器，主要装载的是处理请求的组件;Service主要为了关联Collector和Container,只有这两个结合起来才能够处理请求;Server对外提供接口访问Service,对内维护Service集合包括管理Service生命周期等
	+ **文档组成结构[可不回答]**
	```xml
	<!-- Server代表整个容器，是Tomcat的顶层元素。服务器默认在8005端口，shutdown命令=关闭Tomcat -->
	<Server>
	    <Listener />
	    <GlobaNamingResources></GlobaNamingResources>
	    <!-- Service包含多个Connector元素，而这些Connector元素共享一个Engine元素。 -->
	    <Service>
	    	<!-- Connector元素代表与客户时间交互的组件，它负责接收客户的请求，以及向客户响应结果，配置http为https主要是修改Connector -->
	        <Connector />
	        <!-- 每个Service只能有一个Engine元素，处理同一个Service中所有Connector元素接收到的客户请求.Engine用来处理Connetcor收到的Http请求它匹配请求和自己的虚拟主机，并把请求转给对应的Host来处理 -->
	        <Engine>
	            <Logger />
	            <Realm />
	            	<!-- 一个Engine包含多个host元素，每个host元素定义了一个虚拟主机，它包含一个或多个Web应用 -->
	                <host>
	                    <Logger />
	                    <!-- 由Context接口定义.是使用最频繁的元素，对应于一个Web App -->
	                    <Context />
	                </host>
	        </Engine>
	    </Service>
	</Server>
	```

**类加载流程**

Tomcat的类加载机制是违背双亲委托机制的，对于一些未加载的非基础类(Object、String)等，各个web应用自己的类加载器(WebAppClassLoader)加载，加载不到时在交给CommonClassLoader走双亲委托

当应用需要一个类时，则会按照以下顺序进行类加载：
1) 使用boostrap引导类加载器加载
2) 使用system系统类加载器加载
3) 使用应用类加载器在WEB-INF/classes中加载
4) 使用应用类加载器在WEB-INF/lib中加载
5) 使用common类加载器在CATALINA_HOME/lib中加载

**线程模型**

支持以下四种线程模型

 |描述
-|-
BIO|同步阻塞，每个请求都会创建一个线程
NIO|同步非阻塞，比传统的BIO能更好的支持大并发，tomcat8.0后默认采用该模式
APR|tomcat以JNI形式调用http服务器的核心动态链接库来处理读取与网络传输操作，需要编译安装APR库
AIO|异步非阻塞,tomcat8.0后支持

### 2. tomcat如何调优，涉及哪些参数

tomcat调优主要从四个方面考虑1）吞吐量 2）响应时间 3）CPU负载 4）内存利用率

**[1]Tomcat启动参数调优**

Tomcat启动参数位于tomcat安装目录\bin目录下，linux是catalina.sh文件，windows是catalina.bat文件
+ 设置-Xms(最小堆内存) -Xmx(最大堆内存)一致，避免当Xms向Xmx变化时，CPU高速运转出发垃圾回收机制，严重时导致系统卡壳
  [tip]在设置Xmx时先执行`java -Xms 1500m -version`,如果能正常显示版本信息，则证明可用
+ -Xmn: 设置年轻代大小为512m,整个堆大小=年轻代+老年代+持久代。持久代一般大小为64m,所以增大年轻代后，老年代将减少。官方推荐设置整个堆的3/8
+ -Xss: 设置每个线程的堆栈大小，一般不宜超过1M

**[2]Tomcat容器内调优**

打开[tomcat安装目录]\conf\server.xml,更改后的配置如下

```bash
<Connector port="8080" protocol="HTTP/1.1"           
URIEncoding="UTF-8"  minSpareThreads="25" maxSpareThreads="75"          
enableLookups="false" disableUploadTimeout="true" connectionTimeout="20000" 
acceptCount="300"  maxThreads="300" maxProcessors="1000" minProcessors="5"
useURIValidationHack="false"
compression="on" compressionMinSize="2048"
compressableMimeType="text/html,text/xml,text/javascript,text/css,text/plain" 
redirectPort="8443" />
```

-URIEncoding="UTF-8": 使得url可以解析带有中文的url
-minSpareThreads: 最小备用线程数，tomcat启动时初始化的线程数
-maxSpareThreads: 如果空闲的线程数大于该设置数，则终止多余的空闲线程,减少池中线程总数
-enableLookups: 设置为false,关闭DNS查询，从而消除DNS查询对性能的影响
-disableUploadTimeout: 允许servlet容器，正在执行使用一个较长的连接超时值，以使Servlet有较长的时间来执行完成，默认为false
-connectionTimeout: 网络连接超时时间毫秒数,默认60s
-acceptCount: 当线程数到达maxThreads后，后续请求会放入等待队列，acceptCount即为等待队列的大小
-maxThreads： 可创建的最大线程数，即最大并发数
-maxProcessors与minProcessors： 在 Java中线程是程序运行时的路径，是在一个程序中与其它控制线程无关的、能够独立运行的代码段。它们共享相同的地址空间。多线程帮助程序员写出CPU最大利用率的高效程序，使空闲时间保持最低，从而接受更多的请求。 通常Windows是1000个左右，Linux是2000个左右。？？？
-useURIValidationHack: 禁用url检查
-compression： 打开压缩功能
-compressionMinSize： 启用压缩的输出内容大小，默认为2K
-noCompressionUserAgents="gozilla, traviata"： 设置不启用压缩的浏览器
-compressableMimeType： 压缩类型
-redirectPort: 如果走https协议的话，则会用到

### 3. 讲讲Spring加载流程

初始化环境 -〉加载配置文件 -〉实例化bean -〉调用Bean显示信息
// TODO 详细重点说明

### 4. Spring AOP的实现原理, AOP中的几个术语，它们是怎么相互工作的

两种主要实现方式：JDK动态代理与CGLIB
在Spring5中DefaultAopProxyFactory中调用createAopProxy(AdvisedSupport config)创建AopProxy
若AdvisedSupport中设置optimize=true并且proxyTargetClass=true并且目标targetClass不是interface和proxy,则采用ObjenesisCglibAopProxy创建AopProxy,否则，采用JdkDynamicAopProxy创建AopProxy

JdkDynamicAopProxy实现InvocationHandler接口的方法invoke(Object proxy, Method method, Object[] args)得到AopProxy，
其中较为重要的是通过AdvisedSupport的getInterceptorsAndDynamicInterceptionAdvice(Method method, Class<?> tagetClass)获取拦截器链，该方法在DefaultAdvisorChainFactory中实现,其中，主要通过DefaultAdvisorAdapterRegistry.getInterceptors(Advisor advisor)获取拦截器，这样就和advisor连接起来了。最后通过getInterceptors中的AdvisorAdpter获取MethodBeforeInterceptor、AfterReturningInterceptor、ThrowsAdviceInterceptor,
如在AfterReturningInterceptor中，其实现了MethodInterceptor与AfterAdvice, 从而在invoke(MethodInvocation mi)中先调用mi.process(), 然后调用advice.afterReturning就完成了后置增强

ObjenesisCglibAopProxy通过createProxyClassAndInstance(Enhancer enhancer, Callback[] callbacks)创建AopProxy, enhancer.createClass()创建proxyClass, proxyClass.getDeclaredConstructor()创建Constructor, 最后constructor.newInstance()获取proxyInstance()

**主要术语**

*advice通知* 拦截增强
*pointcut切入点* 目标类
*advisor* 通过其子类PointcutAdvisor将Advice与PointCut连接起来

### 5. 讲讲Spring事务的传播属性

+ **REQUIRED**：支持当前事务，如果当前没有事务，就新建一个事务。默认传播属性
[辅助理解]ServiceB.methodB的事务级别定义为PROPAGATION_REQUIRED,那么由于执行ServiceA.methodA的时候，ServiceA.methodA已经起了事务，这时调用ServiceB.methodB，ServiceB.methodB看到自己已经运行在ServiceA.methodA的事务内部，就不再起新的事务。而假如ServiceA.methodA运行的时候发现自己没有在事务中，他就会为自己分配一个事务。这样，在ServiceA.methodA或者在ServiceB.methodB内的任何地方出现异常，事务都会被回滚。即使ServiceB.methodB的事务已经被提交，但是ServiceA.methodA在接下来fail要回滚，ServiceB.methodB也要回滚。

+ **REQUIRES_NEW**： 支持当前事务，如果当前没有事务，则新建一个事务且挂起外部事务
[辅助理解]如ServiceA.methodA的事务级别为PROPAGATION_REQUIRED，ServiceB.methodB的事务级别为PROPAGATION_REQUIRES_NEW，那么当执行到ServiceB.methodB的时候，ServiceA.methodA所在的事务就会挂起，ServiceB.methodB会起一个新的事务，等待ServiceB.methodB的事务完成以后，A才继续执行。他与PROPAGATION_REQUIRED的事务区别在于事务的回滚程度了。因为ServiceB.methodB是新起一个事务，那么就是存在两个不同的事务。如果ServiceB.methodB已经提交，那么ServiceA.methodA失败回滚，ServiceB.methodB是不会回滚的。如果ServiceB.methodB失败回滚，如果他抛出的异常被ServiceA.methodA捕获，ServiceA.methodA事务仍然可能提交

+ **MANDATORY**: 支持当前事务，如果当前没有事务，则抛出异常
+ **SUPPORTS**： 支持当前事务，如果当前没有事务，就以非事务方式执行
+ **NOT_SUPPORTED**： 以非事务方式执行，如果当前存在事务，则挂起
+ **NEVER**： 以非事务方式执行，如果当前存在事务，则抛出异常

### 6. Spring如何管理事务的

### 7. Spring怎么配置事务(具体说出一些关键的xml元素)

### 8. 说说你对Spring的的理解，非单例注入的原理？它的生命周期？循环注入的原理?

### 9. SpringMVC中DispatcherServlet初始化过程

### 10. Netty的线程模型， netty如何基于reactor模型上实现的

### 11. 为什么选择netty

### 12. 谈谈TCP三次握手，四次挥手

### 13. 什么是TCP粘包、拆包，解决方式是什么

### 14. Netty的fashwheeltimer的用法，实现原理，是否出现过调用不够准时，怎么解决

### 15. Netty的心跳处理在弱网下怎么办

### 16. Netty的通许协议是什么样的

### 17. SpringMVC用到的注解，作用是什么，原理

### 18. SpringBot启动机制

