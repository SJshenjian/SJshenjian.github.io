---
title: 美团面试篇
date: 2019-12-2 17:23:25
category: [JAVA]
tag: [JAVA,面试]
---

### 1. java虚拟机内存模型

[java内存模型](https://shenjian.online/2019/03/21/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E3%80%81JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E3%80%81JAVA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/)

### 2. 内存溢出一般发生在哪个区？永久代会不会导致内存溢出

堆内存溢出、栈内存溢出。永久代是JDK1.7中方法区的一种实现，会导致内存溢出，最常见的是大量JSP文件导致永久代溢出

### 3. 动态加载类的框架了解哪些

JDK动态代理、CGLIB框架 [proxy](https://github.com/SJshenjian/web-project/blob/master/proxy)

### 4. 动态代理一般有哪几种实现方式？动态代理的应用场景有哪些

JDK动态代理、CGLIB框架 [proxy](https://github.com/SJshenjian/web-project/blob/master/proxy)

应用场景：
+ 统计每个API的请求耗时
+ 统一的日志输出
+ 检验被调用的API是否已经登录和权限鉴定
+ 事务处理

### 5. 栈会不会溢出？栈溢出一般抛什么异常？jvm在哪里设置栈的大小？设置的参数是什么？

会。StackOverflowError -Xss256K

### 6. 用过哪些命令查看jvm的状态、堆栈信息？

```bash
# 
top # 列出消耗CPU靠前的进程
top + H # 列出消耗CPU靠前的线程
jstack [进程]|grep -A 10 [线程的16进制] # jstack查找这个线程的信息 -A 10表示查找到所在行的后10行

# 频繁GC问题或内存溢出问题
jps # 线程PID查看
jstat -gc 3331 250 20 # 查看GC情况
jstat -gccause # 额外输出上次GC原因
jmap -dump:format=b,file=heapDump # 3331生成堆转储文件

# 死锁问题
jps # 线程PID查看
jstack 1159 > /opt/temp/dump1 # 转储查看线程情况
```

[详细参考](https://www.cnblogs.com/snake23/archive/2019/01/28/10329149.html)

### 7. jvm的垃圾回收机制

垃圾收集算法： 复制算法、标记-清除算法、标记-整理算法、分代收集算法
[垃圾回收算法的实现原理](https://shenjian.online/2019/11/03/%E8%85%BE%E8%AE%AF%E7%AF%87%E4%B9%8BJVM/#6-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86)
[几种垃圾收集器](https://shenjian.online/2019/11/03/%E8%85%BE%E8%AE%AF%E7%AF%87%E4%B9%8BJVM/#5-%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E5%87%A0%E7%A7%8D%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%8C%E5%90%84%E8%87%AA%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%8C%E9%87%8D%E7%82%B9%E8%AE%B2%E4%B8%8Bcms%E5%92%8CG1%EF%BC%8C%E5%8C%85%E6%8B%AC%E5%8E%9F%E7%90%86%EF%BC%8C%E6%B5%81%E7%A8%8B%EF%BC%8C%E4%BC%98%E7%BC%BA%E7%82%B9)

### 8. java类加载机制？如何实现自定义类加载器？findClass与loadClass的区别？

[类加载机制](https://my.oschina.net/u/1458864/blog/2004785)

**实现自定义类加载器**
继承自ClassLoader，并重写findClass()与loadClass()

**区别**
findClass()用于写类加载逻辑，loadClass()里的逻辑里如果父类加载器加载失败则会调用自己的findClass()来完成，保证了双亲委派原则
如果不想破坏双亲委派模型，只需要重写findClass();如果想打破双亲委派模型，则重写loadClass()

### 8. String、StringBuffer、StringBuilder的区别？对应的使用场景？

item|'+'区别|多线程|性能|使用场景|优化
-|-|-|-|-|-
String|不可变类，重新创建字符串|不安全|操作少量数据，字符串不变时|无
StringBuilder|可变类，原字符串基础上生成字符串|安全|性能最好（比StringBuffer高10%~15%）|单线程用于操作大量数据（方法内部，用完回收）|尽可能指定容量（默认16，不超过16字符不用指定），不指定显著降低性能
StringBuffer|可变类，原字符串基础上生成字符串|安全|性能好|主要用在全局变量中，多线程下安全|同StringBuilder

### 9. 如何实现不可变的类

+ class声明为final,不可以被继承
+ field都是private final,不能提供它们的setter方法
+ 使用私有的构造器通过深拷贝初始化成员变量
+ 在getter方法中不能返回对象本身，返回对象的拷贝
+ 使用建造者模型创建不可变类

### 10. 浅复制和深复制？怎样实现深复制？

item|值类型拷贝|引用类型拷贝
浅拷贝|独立副本|拷贝引用
深拷贝|独立副本|拷贝引用对象及其子对象

### 11. HashMap、HashTable、ConcurrentHashMap的区别？

[ConcurrentHashMap与HashMap等的区别](https://shenjian.online/2019/02/14/ConcurrentHashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/#2-ConcurrentHashMap%E4%B8%8EHashMap%E7%AD%89%E7%9A%84%E5%8C%BA%E5%88%AB)

### 12. CAS是一种什么样的同步机制

[使用循环CAS来实现原子操作](https://shenjian.online/2019/06/02/Java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8B%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/#2-1-%E4%BD%BF%E7%94%A8%E5%BE%AA%E7%8E%AFCAS%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C)

### 13. NIO的原理，包括哪几个组件

**1) Channel**

**实现**
+ FileChannel: 读写文件
+ DatagramChannel: UDP协议网络通信
+ SocketChannel: TCP协议网络通信
+ ServerSocketChannel: 监听TCP连接

[扩展]Channel与Stream的区别
- Channel是双向的，可读可写；Stream是单向的(所以分为InputStream、OutputStream)
- Channel有非阻塞I/O模式；Stream为传统阻塞I/O模式

**2) Buffer**

有三个重要的变量
+ capacity: 总容量
+ position: 指示当前位置
+ limit: 读写边界位置

几个重要方法：
+ flip(): 设置`limit = position;position = 0;`，对buffer读取前调用
+ rewind(): 设置`position = 0;`,对buffer读取前进行调用，比如读取同一个buffer数据写入多个通道时会用到
+ clear(): 设置`position = 0;limit = capacity;`,对buffer重新写入时调用
+ compact(): 将未读完的数据(position~limit)之间的数据移动到缓冲区开头，并将position设置为这段数据末尾的下一个位置。等价于向缓冲区重新写入了这一段数据

**3) Selector**

Selector选择器用于采集各个通道的状态。我们先将通道注册到选择器，并设置好关心的事件，然后调用select()方法，线程挂起，让出CPU，静静等待事件发生。

通道有4个事件可供监听
+ SelectionKey.OP_ACCEPT: 有可以接受的连接
+ SelectionKey.OP_CONNECT: 连接成功
+ SelectionKey.OP_READ: 有数据可读
+ SelectionKey.OP_WRITE: 可以写入数据

[NIO](https://github.com/SJshenjian/design-pattern/tree/master/src/main/java/jdk/INio)

### 14. 简单介绍一下java的反射机制？反射在哪些地方有应用场景？

JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能调用他的任一方法

应用场景：
+ Spring中的IOC/DI
+ JDBC中的驱动加载
