---
title: 美团面试篇
date: 2019-12-2 17:23:25
category: [JAVA]
tag: [JAVA,面试]
---

### 1. java虚拟机内存模型

[java内存模型](https://shenjian.online/2019/03/21/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E3%80%81JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E3%80%81JAVA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/)

### 2. 内存溢出一般发生在哪个区？永久代会不会导致内存溢出

堆内存溢出、栈内存溢出。永久代是JDK1.7中方法区的一种实现，会导致内存溢出，最常见的是大量JSP文件导致永久代溢出

### 3. 动态加载类的框架了解哪些

JDK动态代理、CGLIB框架 [proxy](https://github.com/SJshenjian/web-project/blob/master/proxy)

### 4. 动态代理一般有哪几种实现方式？动态代理的应用场景有哪些

JDK动态代理、CGLIB框架 [proxy](https://github.com/SJshenjian/web-project/blob/master/proxy)

应用场景：
+ 统计每个API的请求耗时
+ 统一的日志输出
+ 检验被调用的API是否已经登录和权限鉴定
+ 事务处理

### 5. 栈会不会溢出？栈溢出一般抛什么异常？jvm在哪里设置栈的大小？设置的参数是什么？

会。StackOverflowError -Xss256K

### 6. 用过哪些命令查看jvm的状态、堆栈信息？

```bash
# 
top # 列出消耗CPU靠前的进程
top + H # 列出消耗CPU靠前的线程
jstack [进程]|grep -A 10 [线程的16进制] # jstack查找这个线程的信息 -A 10表示查找到所在行的后10行

# 频繁GC问题或内存溢出问题
jps # 线程PID查看
jstat -gc 3331 250 20 # 查看GC情况
jstat -gccause # 额外输出上次GC原因
jmap -dump:format=b,file=heapDump # 3331生成堆转储文件

# 死锁问题
jps # 线程PID查看
jstack 1159 > /opt/temp/dump1 # 转储查看线程情况
```

[详细参考](https://www.cnblogs.com/snake23/archive/2019/01/28/10329149.html)

### 7. jvm的垃圾回收机制

垃圾收集算法： 复制算法、标记-清除算法、标记-整理算法、分代收集算法
[垃圾回收算法的实现原理](https://shenjian.online/2019/11/03/%E8%85%BE%E8%AE%AF%E7%AF%87%E4%B9%8BJVM/#6-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86)
[几种垃圾收集器](https://shenjian.online/2019/11/03/%E8%85%BE%E8%AE%AF%E7%AF%87%E4%B9%8BJVM/#5-%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E5%87%A0%E7%A7%8D%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%8C%E5%90%84%E8%87%AA%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%8C%E9%87%8D%E7%82%B9%E8%AE%B2%E4%B8%8Bcms%E5%92%8CG1%EF%BC%8C%E5%8C%85%E6%8B%AC%E5%8E%9F%E7%90%86%EF%BC%8C%E6%B5%81%E7%A8%8B%EF%BC%8C%E4%BC%98%E7%BC%BA%E7%82%B9)

### 8. java类加载机制？如何实现自定义类加载器？findClass与loadClass的区别？

[类加载机制](https://my.oschina.net/u/1458864/blog/2004785)

**实现自定义类加载器**
继承自ClassLoader，并重写findClass()与loadClass()

**区别**
findClass()用于写类加载逻辑，loadClass()里的逻辑里如果父类加载器加载失败则会调用自己的findClass()来完成，保证了双亲委派原则
如果不想破坏双亲委派模型，只需要重写findClass();如果想打破双亲委派模型，则重写loadClass()

### 8. String、StringBuffer、StringBuilder的区别？对应的使用场景？

item|'+'区别|多线程|性能|使用场景|优化
-|-|-|-|-|-
String|不可变类，重新创建字符串|不安全|操作少量数据，字符串不变时|无
StringBuilder|可变类，原字符串基础上生成字符串|安全|性能最好（比StringBuffer高10%~15%）|单线程用于操作大量数据（方法内部，用完回收）|尽可能指定容量（默认16，不超过16字符不用指定），不指定显著降低性能
StringBuffer|可变类，原字符串基础上生成字符串|安全|性能好|主要用在全局变量中，多线程下安全|同StringBuilder

### 9. 如何实现不可变的类

+ class声明为final,不可以被继承
+ field都是private final,不能提供它们的setter方法
+ 使用私有的构造器通过深拷贝初始化成员变量
+ 在getter方法中不能返回对象本身，返回对象的拷贝
+ 使用建造者模型创建不可变类

### 10. 浅复制和深复制？怎样实现深复制？

item|值类型拷贝|引用类型拷贝
浅拷贝|独立副本|拷贝引用
深拷贝|独立副本|拷贝引用对象及其子对象

### 11. HashMap、HashTable、ConcurrentHashMap的区别？

[ConcurrentHashMap与HashMap等的区别](https://shenjian.online/2019/02/14/ConcurrentHashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/#2-ConcurrentHashMap%E4%B8%8EHashMap%E7%AD%89%E7%9A%84%E5%8C%BA%E5%88%AB)

### 12. CAS是一种什么样的同步机制

[使用循环CAS来实现原子操作](https://shenjian.online/2019/06/02/Java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8B%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/#2-1-%E4%BD%BF%E7%94%A8%E5%BE%AA%E7%8E%AFCAS%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C)

### 13. NIO的原理，包括哪几个组件

**1) Channel**

**实现**
+ FileChannel: 读写文件
+ DatagramChannel: UDP协议网络通信
+ SocketChannel: TCP协议网络通信
+ ServerSocketChannel: 监听TCP连接

[扩展]Channel与Stream的区别
- Channel是双向的，可读可写；Stream是单向的(所以分为InputStream、OutputStream)
- Channel有非阻塞I/O模式；Stream为传统阻塞I/O模式

**2) Buffer**

有三个重要的变量
+ capacity: 总容量
+ position: 指示当前位置
+ limit: 读写边界位置

几个重要方法：
+ flip(): 设置`limit = position;position = 0;`，对buffer读取前调用
+ rewind(): 设置`position = 0;`,对buffer读取前进行调用，比如读取同一个buffer数据写入多个通道时会用到
+ clear(): 设置`position = 0;limit = capacity;`,对buffer重新写入时调用
+ compact(): 将未读完的数据(position~limit)之间的数据移动到缓冲区开头，并将position设置为这段数据末尾的下一个位置。等价于向缓冲区重新写入了这一段数据

**3) Selector**

Selector选择器用于采集各个通道的状态。我们先将通道注册到选择器，并设置好关心的事件，然后调用select()方法，线程挂起，让出CPU，静静等待事件发生。

通道有4个事件可供监听
+ SelectionKey.OP_ACCEPT: 有可以接受的连接
+ SelectionKey.OP_CONNECT: 连接成功
+ SelectionKey.OP_READ: 有数据可读
+ SelectionKey.OP_WRITE: 可以写入数据

[NIO](https://github.com/SJshenjian/design-pattern/tree/master/src/main/java/jdk/INio)

### 14. 简单介绍一下java的反射机制？反射在哪些地方有应用场景？

JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能调用他的任一方法

应用场景：
+ Spring中的IOC/DI
+ JDBC中的驱动加载

### 15. spring加载bean的流程

[Spring加载流程](https://shenjian.online/2019/11/05/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E7%AF%87/#3-%E8%AE%B2%E8%AE%B2Spring%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B)

### 16. java线程池？线程池构造函数的几个参数含义？keepAliveTime解释一下？

```java
public class ThreadPoolExecutor {
        public ThreadPoolExecutor(int corePoolSize,
                                  int maximumPoolSize,
                                  long keepAliveTime,
                                  TimeUnit unit,
                                  BlockingQueue<Runnable> workQueue,
                                  ThreadFactory threadFactory,
                                  RejectedExecutionHandler handler) {
            // ...
        }
}
```

线程池的构造参数有7个:
+ corePoolSize: the number of threads to keep in the pool, even if they are idle, unless {@code allowCoreThreadTimeOut} is set
+ maximumPoolSize: the maximum number of threads to allow in the pool
+ keepAliveTime: when the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating
+ unit: the time unit for the {@code keepAliveTime} argument
+ workQueue: the queue to use for holding tasks before they are executed. This queue will hold only the {@code Runnable} tasks submitted by the {@code execute} method
    - ArrayBlockingQueue
    - LinkedBlockingQueue
    - SynchronousQueue
    - PriorityBlockingQueue
+ threadFactory: the factory to use when the executor creates a new thread
+ handler: the handler to use when execution is blocked because the thread bounds and queue capacities are reached
    - CallerRunsPolicy: A handler for rejected tasks that runs the rejected task directly in the calling thread of the {@code execute} method
    - AbortPolicy: A handler for rejected tasks that throws a {@code RejectedExecutionException}.
    - DiscardPolicy: A handler for rejected tasks that silently discards the rejected task.
    - DiscardOldestPolicy: A handler for rejected tasks that discards the oldest unhandled request and then retries {@code execute}


### 17. 一个接口，要去调用另外5个接口，每一个接口都会返回数据给这个调用接口，调用接口要对数据进行合并并返回给上层。这样一种场景可能用到并发包下的哪些类？你会怎么去实现这样的业务场景

```java
class Solution {
    private static ExecutorService executorService = Executors.newFixedThreadPool(3);
    public static void main(String[] args) {
        CyclicBarrier barrier = new CyclicBarrier(5, () -> {
            // 执行结果汇总
        });
        executorService.execute(() -> {
            // 执行接口1调用,其他接口调用类似
            try {
                barrier.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (BrokenBarrierException e) {
                e.printStackTrace();
            }
        });
    }
}
```

### 18. CountDownLatch和CyclicBarrier的区别

所有线程必须全部到达栅栏处，才能继续执行；闭锁结束前，不允许线程执行，结束时，允许所有线程执行
栅栏等待线程；闭锁等待事件
栅栏可以使参与方在栅栏处反复汇集；闭锁是一次性事件，一旦进入终止状态，不能被重置

[JAVA同步工具类之闭锁](https://shenjian.online/2019/02/24/JAVA%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B9%8B%E9%97%AD%E9%94%81/)
[JAVA同步工具类之栅栏](https://shenjian.online/2019/02/24/JAVA%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B9%8B%E6%A0%85%E6%A0%8F/)

### 19. 线程加锁有哪些方式？synchronized和lock的区别

synchronized与lock

[synchronized和ReentrantLock之间的选择](https://shenjian.online/2019/03/29/Lock%E6%8E%A5%E5%8F%A3%E5%92%8CReentrantLock/#6-synchronized%E5%92%8CReentrantLock%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%89%E6%8B%A9)

### 20. volatile关键字的作用？为什么使用AtomicLong而不使用Long?AtomicLong的底层是怎么实现的？

[Java并发机制底层实现原理之volatile](https://shenjian.online/2019/01/10/Java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8Bvolatile/)

### 21. mysql的存储引擎有哪几种

功能|InnoDB|MyISAM|Memory
-|-|-|-
存储限制|64TB|256TB|RAM
支持事务|Yes|No|No
支持全文索引|No|Yes|No
支持数索引|Yes|Yes|Yes
支持哈希索引|No|No|Yes
支持数据缓存|Yes|No|N/A
支持外键|Yes|No|No

## 22. sql优化有哪些着手点？组合索引的最左前缀原则的含义

[数据库优化的思路](https://shenjian.online/2019/11/07/MySQL%E9%9D%A2%E8%AF%95%E7%AF%87/#8-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E7%9A%84%E6%80%9D%E8%B7%AF)

最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式

### 23. springmvc处理请求的流程

[SpringMVC用到的注解，作用是什么，原理](https://shenjian.online/2019/11/05/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E7%AF%87/#17-SpringMVC%E7%94%A8%E5%88%B0%E7%9A%84%E6%B3%A8%E8%A7%A3%EF%BC%8C%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%8E%9F%E7%90%86)

### 24. spring的事务怎么使用？事务回滚？自定义异常？

### 25. 脏读？幻读？
