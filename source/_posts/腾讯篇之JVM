### 1. 什么情况下会发生栈内存溢出

栈分配空间太小，或执行的方法递归层数太多创建了太多的栈帧导致溢出
解决方案：配置-Xss参数增加线程栈大小，优化程序也至关重要

### 2. JVM的内存结构，Eden和Survivor的比例

内存结构：
+ 堆：存放对象
+ 方法区： 存放类和变量
+ JAVA虚拟机栈：存放运行时栈帧
+ 本地方法栈
+ 程序计数器

Eden区是一块，Survivor是两块，均属于堆中的新生代
Eden和Survivor的比例是8：1：1，可以通过-XX:SurvivorRatio来设定

JDK1.8后取消了方法区，将永久代放到了本地内存里面

### 3. JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor

+ 共享内存区 = 持久代 + 堆
+ 持久代 = 方法区 + 其他
+ 堆 = 新生代 + 老年代 （1:2通过-XX:NewRatio设置）
+ 新生代 = Eden + S0 + S1(8:1:1通过-XX:SurvivorRatio设置)

Survivor具有预筛选保证，只有对象经历了16次Minor GC才会被送到老年代，Survivor可以减少被送到老年代的对象，进而减少Full GC发生
有两个Survivor，在Minor GC后，可以保证一个为空，另一个非空且无内存碎片


### 4. JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数

完整GC流程：
+ 当Eden区满了，JVM触发一次Minor GC，以收集新生代的垃圾，存活下来的对象，会被转移到Survivor区
+ 大对象(如很长的字符串)直接进入老年代
+ 如果对象在Eden出生，每经历过一次MinorGC，并且被Survivor容纳的话，年龄加1，直到年龄超过15，就会进入老年代
+ Major GC发生在老年代，通常会伴随着至少一次Minor GC，比Minor GC慢10倍以上

-Xss: 栈容量
-Xms：设置最小堆内存 
-Xmx：设置最大堆内存
-Xmn10M：设置新生代10M
-XX:SurvivorRatio=8：设置Eden、Survivor比例8:1
-XX:PermSize=32M：永久代最小内存32M
-XX:MaxPermSize=64M：永久代最大扩展内存64M
-XX:+HeapDumpOnOutOfMemoryError：堆内存溢出时Dump出当前的内存堆转储快照以便事后分析

### 5. 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点

+ Serial收集器：新生代单线程的收集器，收集垃圾时，必须stop the world,使用复制算法
+ ParNew收集器：新生代Serial多线程版本收集器，也需要stop the world,使用复制算法
+ Paraller Scavenge收集器：新生代并发的多线程收集器，目标达到一个可控的吞吐量，使用复制算法

+ Serial Old收集器： 是Serial收集器的老年代版本，单线程，使用标记整理算法
+ Parallel Old收集器: Parallel Scavenge收集器的老年代版本，多线程，使用标记整理算法
+ CMS收集器：是一种以最短回收停顿时间为目标的老年代收集器，使用标记清除算法，运行过程:初始标记-并发标记-重新标记-并发清除，收集后会产生大量空间碎片
+ G1收集器： 可作用于新生代与老年代，是标记整理算法，运行过程:初始标记-并发标记-最终标记-筛选标记，不会产生碎片，可以精确的控制停顿

|CMS收集器|G1收集器
-|-|-
算法类型|标记-清除|标记-整理
收集范围|老年代|新生代、老年代
目标|最短的停顿时间为目标|可预测的垃圾回收时间

### 6. 垃圾回收算法的实现原理

+ 引用计数法 堆中每个对象拥有一个引用计数。被引用一次，计数加1，被引用变量值变为null,则计数减1，直到计算为0，则表示变为无用对象。缺点是无法识别循环引用对象
+ 引用可达法(根搜索算法) 从一个节点GC ROOT开始，寻找一个引用的节点，找到后，继续寻找这个节点的引用节点，寻找完毕后，剩余的节点则认为是没有被引用的对象

### 7. 当出现了内存溢出，你怎么排错

JVM除了程序计数器其他区域都可能发生内存溢出

**堆溢出OutOfMemoryError**
用visualVM工具分析堆快照(-XX:+HeapDumpOnOutOfMemoryError)
如果发生内存泄漏
1) 找打泄漏的对象 2）找到泄漏对象的GC ROOT 3)根据泄漏对象和GC ROOT找到导致内存泄漏的代码 4) 设法排除泄漏对象和GC ROOT的连接
如果不存在内存泄漏，看下能否增大JVM堆的容量

**栈溢出**
一般由于递归，导致栈空间不足，发生OutOfMemoryError：Java heap space说明运行时常量池移到了堆中

**方法区溢出**
方法区是存放类的地方。如果多个项目有多个相同jar,且都在WEB-INF/lib下，则每个项目都会加载一遍jar,会导致方法区有大量相同类，又不会被GC,则可建立共享lib库，否则尝试增加-XX:MaxPermSize
