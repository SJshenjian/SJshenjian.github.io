### 1. 什么情况下会发生栈内存溢出

栈分配空间太小，或执行的方法递归层数太多创建了太多的栈帧导致溢出
解决方案：配置-Xss参数增加线程栈大小，优化程序也至关重要

### 2. JVM的内存结构，Eden和Survivor的比例

内存结构：
+ 堆：存放对象
+ 方法区： 存放类和变量
+ JAVA虚拟机栈：存放运行时栈帧
+ 本地方法栈
+ 程序计数器

Eden区是一块，Survivor是两块，均属于堆中的新生代
Eden和Survivor的比例是8：1：1，可以通过-XX:SurvivorRatio来设定

JDK1.8后取消了方法区，将永久代放到了本地内存里面

### 3. JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor

+ 共享内存区 = 持久代 + 堆
+ 持久代 = 方法区 + 其他
+ 堆 = 新生代 + 老年代 （1:2通过-XX:NewRatio设置）
+ 新生代 = Eden + S0 + S1(8:1:1通过-XX:SurvivorRatio设置)

Survivor具有预筛选保证，只有对象经历了16次Minor GC才会被送到老年代，Survivor可以减少被送到老年代的对象，进而减少Full GC发生
有两个Survivor，在Minor GC后，可以保证一个为空，另一个非空且无内存碎片


### 4. JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数

完整GC流程：
+ 当Eden区满了，JVM触发一次Minor GC，以收集新生代的垃圾，存活下来的对象，会被转移到Survivor区
+ 大对象(如很长的字符串)直接进入老年代
+ 如果对象在Eden出生，每经历过一次MinorGC，并且被Survivor容纳的话，年龄加1，直到年龄超过15，就会进入老年代
+ Major GC发生在老年代，通常会伴随着至少一次Minor GC，比Minor GC慢10倍以上

-Xms：设置最小堆内存 
-Xmx：设置最大堆内存
-XX:NewRatio：设置新生代与老年代比例
-XX:SurvivorRatio：设置Eden、Survivor比例

### 5. 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点
