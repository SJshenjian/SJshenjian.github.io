---
title: 队列和生产者-消费者模式
date: 2019-02-24 14:00:25
category: 多线程
tag: [多线程]
---

## 1. 阻塞队列

``` bash
/**
 * 桌面搜索应用中的生产者任务和消费者任务
 */
public class FileCrawler implements Runnable{

    private final BlockingQueue<File> queue;
    private final FileFilter fileFilter;
    private final File root;
	...

    @Override
    public void run() {
        try {
            crawl(root);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void crawl(File root) throws InterruptedException {
        File[] files = root.listFiles(fileFilter);
        if (files != null) {
            for (File file: files) {
                if (file.isDirectory()) {
                    crawl(file);
                } else if (!alreadyIndexed(file)){
                    queue.put(file);
                }
            }
        }
    }
}
```

``` bash
/**
 * 索引建立
 */
public class Indexer implements Runnable{

    private final BlockingQueue<File> fileQueue;

    public Indexer(BlockingQueue<File> fileQueue) {
        this.fileQueue = fileQueue;
    }

    @Override
    public void run() {
        while (true) {
            try {
                indexFile(fileQueue.take());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

``` bash
/**
 * 应用启动
 */
public class Window {

    public void startIndexing() {
        BlockingQueue<File> fileQueue = new ArrayBlockingQueue<>(8);
        FileFilter fileFilter = (pathname) -> { return true;};

        String path =  "src" + File.separator + "main" + File.separator + "resources" +
                File.separator + "concurrent";
        File root = new File(path);

        new Thread(new FileCrawler(fileQueue, fileFilter, root)).start();

        for (int i = 0; i < 3; i++) {
            new Thread(new Indexer(fileQueue)).start();
        }
    }
}

```

## 2. 双端队列

JAVA6新增两种容器类型，Deque与BlockingDeque，分别为Queue与BlockingQueue的扩展。 Deque是一种双端队列，实现了队列头和队列尾的高效插入与删除，具体实现包括ArrayDeque和LinkedBlockingDeque.

**工作密取** 在生产者-消费者设计中，所有的消费者拥有一个工作队列，而在工作密取中，每个消费者拥有一个双端队列，如果消费者完成自己双端队列的工作，则可以从其他消费者双端队列末尾秘密的获取工作。
